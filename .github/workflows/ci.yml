name: CI

on:
  push:
    branches: [main]
    paths-ignore:
      - 'docs/**'
      - '.github/**'
      - 'scripts/**'
      - 'website/**'
      - 'uat-repos/**'
      - 'TestData/**'
      - 'assets/**'
      - 'artifacts/**'

concurrency:
  group: versioning-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: write
  checks: write
  pull-requests: read

# CI Optimization: Tests removed from this workflow to eliminate redundancy.
# All quality gates (format, build, test, lint, vulnerability scan) run in PR Validation.
# This workflow only handles versioning after merge, reducing CI time significantly.
jobs:
  version:
    name: Version and Tag
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          token: ${{ secrets.RELEASE_TOKEN }}

      - name: Setup .NET
        uses: actions/setup-dotnet@v5
        with:
          global-json-file: src/global.json

      - name: Install Versionize
        run: dotnet tool install --global Versionize

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Detect release-worthy changes
        id: release_needed
        run: |
          set -euo pipefail

          # We only want to create a new version/tag when the published Docker image
          # would actually change. The final image contains the NativeAOT binary and
          # some example files (see src/Dockerfile).
          #
          # This check is intentionally conservative and focuses on files that can
          # affect the final runtime image contents.
          last_tag=$(git describe --tags --abbrev=0 --match 'v*' 2>/dev/null || true)
          if [ -z "$last_tag" ]; then
            echo "No previous v* tag found; allowing versionize to run."
            echo "release_needed=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Last tag: $last_tag"
          changed=$(git diff --name-only "$last_tag"..HEAD || true)
          if [ -z "$changed" ]; then
            echo "No changes detected since $last_tag; skipping versionize."
            echo "release_needed=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Paths that can affect the published Docker image
          releasable=$(echo "$changed" | grep -E '^(src/|examples/|dotnet-tools\.json$|\.dockerignore$)' || true)

          # Exclude paths that do not change the published runtime image (but may still affect build/test).
          # We intentionally do NOT create new tags/releases for test-only or generated test output changes.
          releasable=$(echo "$releasable" | grep -Ev '^(src/tests/|src/tools/|src/TestResults/|src/src/TestResults/)' || true)
          if [ -z "$releasable" ]; then
            echo "Only non-release-impacting files changed since $last_tag; skipping versionize."
            echo "release_needed=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Release-impacting changes detected:"
          echo "$releasable"
          echo "release_needed=true" >> "$GITHUB_OUTPUT"

      - name: Versionize
        id: versionize
        if: steps.release_needed.outputs.release_needed == 'true'
        run: |
          versionize --exit-insignificant-commits --skip-dirty
          echo "version_bumped=true" >> $GITHUB_OUTPUT
        continue-on-error: true

      - name: Push changes
        if: steps.versionize.outcome == 'success'
        env:
          GIT_TERMINAL_PROMPT: '0'
        run: |
          # Use RELEASE_TOKEN to bypass branch protection
          git remote set-url origin "https://x-access-token:${{ secrets.RELEASE_TOKEN }}@github.com/${{ github.repository }}.git"
          git push --follow-tags
