#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'USAGE'
Usage:
  scripts/pr-github.sh preview --title <title> --body-file <path>
  scripts/pr-github.sh preview --title <title> --body <text>
  scripts/pr-github.sh preview --fill

  scripts/pr-github.sh create --title <title> --body-file <path>
  scripts/pr-github.sh create --title <title> --body <text>
  scripts/pr-github.sh create --fill

  scripts/pr-github.sh create-and-merge --title <title> --body-file <path>
  scripts/pr-github.sh create-and-merge --title <title> --body <text>
  scripts/pr-github.sh create-and-merge --fill

Options:
  --title <title>         PR title (use Conventional Commits style)
  --body-file <path>      Path to a markdown/text file used as PR body
  --body <text>           PR body text (alternative to --body-file)
  --fill                  Let gh derive title/body from commits

Notes:
  - Requires: git + GitHub CLI (gh) authenticated
  - Merge policy: uses rebase-and-merge for linear history (per CONTRIBUTING.md)
USAGE
}

ensure_origin_main_exists() {
  if git show-ref --verify --quiet refs/remotes/origin/main; then
    return 0
  fi

  git fetch origin main >/dev/null 2>&1 || true
}

require_non_empty() {
  local value="$1"
  local label="$2"
  if [[ -z "${value//[[:space:]]/}" ]]; then
    echo "Error: $label must not be empty." >&2
    exit 2
  fi
}

derive_title_from_git() {
  local derived
  derived="$(git log -1 --pretty=%s)"
  if [[ -z "${derived//[[:space:]]/}" ]]; then
    derived="workflow: update"
  fi
  printf '%s' "$derived"
}

derive_body_from_git_or_diff() {
  # Prefer commit body (excluding subject). If missing, fall back to a short auto body.
  local commit_body
  commit_body="$(git log -1 --pretty=%B | tail -n +2 | sed '/^[[:space:]]*$/d' || true)"
  if [[ -n "${commit_body//[[:space:]]/}" ]]; then
    printf '%s\n' "$commit_body"
    return 0
  fi

  local base_ref="origin/main"
  ensure_origin_main_exists
  if ! git show-ref --verify --quiet refs/remotes/origin/main; then
    base_ref="main"
  fi

  local shortstat
  local top_files
  shortstat="$(git diff --shortstat "$base_ref"...HEAD || true)"
  top_files="$(git diff --name-only "$base_ref"...HEAD | head -n 10)"

  printf '%s\n' "Autogenerated PR description (please refine if needed)."
  if [[ -n "${shortstat//[[:space:]]/}" ]]; then
    printf '\n%s\n' "Changes: $shortstat"
  fi
  if [[ -n "${top_files//[[:space:]]/}" ]]; then
    printf '\nFiles (top):\n'
    printf '%s\n' "$top_files" | sed 's/^/- /'
  fi
}

resolve_body_text() {
  if [[ -n "${BODY_TEXT:-}" ]]; then
    printf '%s\n' "$BODY_TEXT"
    return 0
  fi

  if [[ -n "${BODY_FILE:-}" ]]; then
    cat "$BODY_FILE"
    return 0
  fi

  if [[ "${FILL:-false}" == "true" ]]; then
    derive_body_from_git_or_diff
    return 0
  fi

  echo "" # should never happen (validated earlier)
}

print_preview_markdown() {
  local base_ref="origin/main"

  ensure_origin_main_exists
  if ! git show-ref --verify --quiet refs/remotes/origin/main; then
    base_ref="main"
  fi

  local title
  local body
  local file_count
  local add_total
  local del_total
  local shortstat
  local top_files

  if [[ "$FILL" == "true" ]]; then
    title="$(derive_title_from_git)"
  else
    title="$TITLE"
  fi
  body="$(resolve_body_text)"

  file_count="$(git diff --name-only "$base_ref"...HEAD | wc -l | tr -d ' ')"
  add_total="$(git diff --numstat "$base_ref"...HEAD | awk '{a+=$1} END {print a+0}')"
  del_total="$(git diff --numstat "$base_ref"...HEAD | awk '{d+=$2} END {print d+0}')"
  shortstat="$(git diff --shortstat "$base_ref"...HEAD || true)"
  top_files="$(git diff --name-only "$base_ref"...HEAD | head -n 3 | sed 's/^/- /')"

  echo "## PR Preview"
  echo ""
  echo "**Title**"
  echo "- $title"
  echo ""
  echo "**Description**"
  echo "" 
  echo "$body"
  echo ""
  echo "**Diff Summary**"
  if [[ -n "$top_files" ]]; then
    echo "$top_files"
  fi
  echo "- $file_count file(s) changed; +$add_total/-$del_total lines"
  if [[ -n "$shortstat" ]]; then
    echo "- $shortstat"
  fi
}

print_preview() {
  local base_ref="origin/main"

  ensure_origin_main_exists
  if ! git show-ref --verify --quiet refs/remotes/origin/main; then
    base_ref="main"
  fi

  local title
  local file_count
  local add_total
  local del_total
  local shortstat
  local top_files

  if [[ "$FILL" == "true" ]]; then
    title="$(derive_title_from_git)"
  else
    title="$TITLE"
  fi

  file_count="$(git diff --name-only "$base_ref"...HEAD | wc -l | tr -d ' ')"
  add_total="$(git diff --numstat "$base_ref"...HEAD | awk '{a+=$1} END {print a+0}')"
  del_total="$(git diff --numstat "$base_ref"...HEAD | awk '{d+=$2} END {print d+0}')"
  shortstat="$(git diff --shortstat "$base_ref"...HEAD || true)"
  top_files="$(git diff --name-only "$base_ref"...HEAD | head -n 3 | sed 's/^/- /')"

  echo "PR Preview"
  echo "Title: $title"
  echo "Summary:"
  if [[ -n "$top_files" ]]; then
    echo "$top_files"
  fi
  echo "- $file_count file(s) changed; +$add_total/-$del_total lines"
  if [[ -n "$shortstat" ]]; then
    echo "- $shortstat"
  fi
}

require_clean_worktree() {
  if ! git diff --quiet || ! git diff --cached --quiet; then
    echo "Error: working tree has uncommitted changes." >&2
    exit 2
  fi
}

require_not_main() {
  local branch
  branch="$(git branch --show-current)"
  if [[ "$branch" == "main" ]]; then
    echo "Error: refusing to run on 'main'." >&2
    exit 2
  fi
}

parse_args() {
  local -n _title="$1"
  local -n _body_file="$2"
  local -n _fill="$3"

  shift 3

  _title=""
  _body_file=""
  BODY_TEXT=""
  _fill="false"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --title)
        _title="$2"
        shift 2
        ;;
      --body-file)
        _body_file="$2"
        shift 2
        ;;
      --body)
        BODY_TEXT="$2"
        shift 2
        ;;
      --fill)
        _fill="true"
        shift
        ;;
      -h|--help)
        usage
        exit 0
        ;;
      *)
        echo "Error: unknown arg: $1" >&2
        usage
        exit 2
        ;;
    esac
  done

  if [[ "$_fill" != "true" ]]; then
    if [[ -z "$_title" ]]; then
      echo "Error: provide --fill OR --title plus one of: --body-file, --body." >&2
      usage
      exit 2
    fi

    if [[ -n "$BODY_TEXT" && -n "$_body_file" ]]; then
      echo "Error: provide only one of --body or --body-file." >&2
      exit 2
    fi

    if [[ -z "$BODY_TEXT" && -z "$_body_file" ]]; then
      echo "Error: provide --body or --body-file when not using --fill." >&2
      exit 2
    fi

    if [[ -n "$_body_file" && ! -f "$_body_file" ]]; then
      echo "Error: body file not found: $_body_file" >&2
      exit 2
    fi

    require_non_empty "$_title" "--title"
    require_non_empty "$(resolve_body_text)" "PR body"
  fi
}

ensure_pr_exists() {
  local branch
  branch="$(git branch --show-current)"

  if PAGER=cat gh pr view --json number,url -q '.number' >/dev/null 2>&1; then
    return 0
  fi

  echo "No existing PR found for branch '$branch'; creating..." >&2
  if [[ "$FILL" == "true" ]]; then
    local resolved_title
    local resolved_body
    resolved_title="$(derive_title_from_git)"
    resolved_body="$(resolve_body_text)"
    require_non_empty "$resolved_title" "PR title"
    require_non_empty "$resolved_body" "PR body"
    PAGER=cat gh pr create --base main --head "$branch" --title "$resolved_title" --body "$resolved_body"
  else
    local resolved_body
    resolved_body="$(resolve_body_text)"
    require_non_empty "$TITLE" "PR title"
    require_non_empty "$resolved_body" "PR body"
    if [[ -n "${BODY_FILE:-}" ]]; then
      PAGER=cat gh pr create --base main --head "$branch" --title "$TITLE" --body-file "$BODY_FILE"
    else
      PAGER=cat gh pr create --base main --head "$branch" --title "$TITLE" --body "$resolved_body"
    fi
  fi
}

get_pr_number() {
  PAGER=cat gh pr view --json number -q '.number'
}

main() {
  if [[ $# -lt 1 ]]; then
    usage
    exit 2
  fi

  local cmd
  cmd="$1"
  shift

  case "$cmd" in
    preview|create|create-and-merge)
      ;;
    *)
      echo "Error: unknown command: $cmd" >&2
      usage
      exit 2
      ;;
  esac

  require_not_main

  TITLE=""
  BODY_FILE=""
  FILL="false"

  parse_args TITLE BODY_FILE FILL "$@"

  if [[ "$cmd" == "preview" ]]; then
    print_preview_markdown
    exit 0
  fi

  require_clean_worktree

  if ! command -v gh >/dev/null 2>&1; then
    echo "Error: gh is not installed." >&2
    exit 2
  fi

  if ! gh auth status >/dev/null 2>&1; then
    echo "Error: gh is not authenticated. Run: gh auth login" >&2
    exit 2
  fi

  git push -u origin HEAD

  ensure_pr_exists

  local pr
  pr="$(get_pr_number)"
  echo "PR: #$pr" >&2

  if [[ "$cmd" == "create-and-merge" ]]; then
    PAGER=cat gh pr merge "$pr" --rebase --delete-branch
  fi
}

main "$@"
